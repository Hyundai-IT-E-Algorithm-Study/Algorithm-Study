# 해시 HASH

수정날짜: 2023년 11월 27일 오후 10:11
최종 편집 일시: 2023년 11월 27일 오후 10:11
유형: 개발기본상식

# **해시**

- 해시 함수의 결과 값을 의미
- 저장소(bucket)에서, 값(value)와 매칭되어 저장
- 해시 함수에 key를 적용해 나온 결과인 해시를 버킷 배열의 인덱스로 하고, 그 자리에 value를 저장
- 즉, Hash Method에 의해 반환된 데이터 고유의 숫자 값: hash Code

# **해시 함수란?**

- 해시 함수는 다양한 길이를 가지고 있는 key를, 일정한 길이의 해시로 바꿔주어(key의 길이 > hash의 길이) 공간을 효율적으로 관리할 수 있도록 하는 함수이다.
- **해시 충돌(Hash Collision)을 최소화 하는 해시 함수를 만드는 것이 중요하다.**

# 그렇다면 왜 사용할까?

- 해시의 등장배경은 배열과 리스트로 인함
- 배열은 내부 인덱스를 이용하여 자료의 검색이 한번에 이루어지기 때문에 빠른 검색 속도를 보이는 반면 데이터의 삽입, 삭제 시 많은 데이터가 밀리거나 빈자리를 채우기 위해 이동해야 하기 때문에 많은 시간이 소요된다.
- 반면에 연결 리스트는 삽입, 삭제 시 인근 노드들의 참조 값만 수정해 줌으로써 빠른 처리가 가능했었다.
- 단 처음 노드 마지막 노드 이외의 위치에서 데이터를 삽입, 삭제할 경우나 데이터를 검색할 경우에는 해당 노드를 찾기 위하여 처음부터 순회 검색을 해야 하기 때문에 데이터의 수가 많아질수록 효율이 떨어질 수 밖에 없는 구조다.
- 이러한 한계를 극복하기 위하여 제시된 방법이 바로 해시(Hash)

## **해시 테이블**

![0_rexKDa_myY_CTQoT](https://github.com/Hyundai-IT-E-Algorithm-Study/Algorithm-Study/assets/99467446/e3b0720c-883d-4b5b-b3ff-f9de0def2143)


- 해시 테이블이란, (key, value)의 형태로 데이터를 저장하는 자료구조이다. Hash map, map, dictionary, 연관배열 등의 이름으로도 알려져 있다.
- 해시 함수에 key를 적용해 나온 결과(= 해시)를 배열(버킷)의 인덱스로 하고, 그 자리에 value를 저장하게 되는 것이다.
- **해시 충돌이 일어나지 않는 경우, 해시테이블의 시간 복잡도는 O(1)이다.**

# 해시의 예시

- 예를 들어 "a", "b", "c"의 hashCode가 각각 97,98,99라고 하고 Hash Table의 크기가 10이라고 했을 때 테이블에 저장될 인덱스는 다음과 같다.

```java
97 % 10 = 7

98 % 10 = 8

99 % 10 = 9
```

- 즉, Hash Table의 인덱스 7에는 "a"를 저장하고 8에는 "b", 9에는 "C"를 저장하는 방식이다.
- 이후에 "a"를 검색할 때에는 "a"의 hashCode를 가지고 나머지 연산을 한 결과인 7번 인덱스를 바로 참조하여 데이터를 꺼낼 수 있다.

---

- 4,8,12,16,20,24,28,32 라는 hashCode를 가진 데이터가 있다고 했을 때, 데이터를 저장하기 위해 Hash Table의 크기를 8로 지정했다면 테이블에 저장될 인덱스는 다음과 같다.

```java
4 % 8 = 4

8 % 8 = 0

12 % 8 = 4

16 % 8 = 0

20 % 8 = 4

24 % 8 = 0

28 % 8 = 4

32 % 8 = 0
```

- 데이터를 저장하기 위한 인덱스가 0번과 4번에 집중되는 것을 볼 수 잇다.
- 이처럼 hashCode가 다르더라도 나머지 연산을 한 결과는 같을 수 있으므로 Hash Table의 동일한 인덱스에 저장을 시도하려 할 경우 문제가 발생한다.
- 이렇게 저장하려는 위치에 이미 다른 데이터가 있어서 저장을 할 수 없는 현상을 충돌(collision)이라고 하며 이런 충돌을 최소화 하기 위한 방법으로는 나머지 연산의 값이 최대한 중복되지 않도록 테이블의 크기를 소수(prime number)로 만드는 것이다.
- 다음은 8보다 큰 소수인 11을 테이블의 크기로 지정했을 때 각 데이터들이 테이블에 저장될 인덱스 값이다.

```java
4 % 11 = 4

8 % 11 = 8

12 % 11 = 1

16 % 11 = 5

20 % 11 = 9

24 % 11 = 2

28 % 11 = 6

32 % 11 = 10
```

- 이제는 충돌이 발생하지 않는다. 하지만 Hash Table의 크기를 소수로 만드는 것은 충돌을 줄이는 방법이지 해결하기 위한 방법은 아니다. 추가적으로 10을 저장하려고 한다면 10 % 11 = 10이 되므로 이미 10번의 인덱스에는 32가 들어있기 때문에 충돌이 발생한다. 이처럼 충돌이 발생할 경우 이를 해결하기 위한 방법이 필요하며 충돌 해결 방법으로 개방주소법과 분리 연결법 두가지가 있다.

## **해시 충돌**

- 서로 다른 키가 같은 해시 값을 가지는 경우

### 해시 충돌의 해결법

- **Chaining(체이닝) :** 해시 충돌이 일어났을 때 이를 동일한 버킷에 저장하는데, 이를 연결리스트 형태로 저장하는 방법을 말한다.
    ![0_5RUK--vwS2dPYBQx](https://github.com/Hyundai-IT-E-Algorithm-Study/Algorithm-Study/assets/99467446/1f925d21-4431-4a7a-b2b1-d32d310b454e)

    
    - **시간 복잡도**
        - **탐색 / 삭제**는 키에 해당하는 리스트의 길이에 비례함, 최악의 경우 **O(K)**가 된다. (이때 K는 키 값의 갯수를 의미한다.)
        - **삽입**은 **O(1)**
- **Open Addressing:** 해시 충돌이 일어날 경우, 저장소의 다른 주소도 이용할 수 있게 하는 방법
    ![0_pBvXV8jPgz0XWgDB](https://github.com/Hyundai-IT-E-Algorithm-Study/Algorithm-Study/assets/99467446/ff92a75a-c8f2-43c0-8d5e-f2c3cfa1052f)

    
    - ex) “Sandra Dee”라는 키에 대해 해시 함수를 적용한 결과 152가 나왔다. 그렇지만 152번은 이미 다른 키에 의해 사용되고 있는 공간이다. 따라서 그 다음 비어있는 주소인 153에 저장한다.
    - **시간 복잡도**
        - **탐색, 삽입, 삭제 모두 최상의 경우 O(1), 최악의 경우 O(n)**

## **해시 충돌의 문제가 있음에도 해시 테이블을 쓰는 이유는 ?**

1. 많은 양의 데이터를 **빠르게 탐색**할 수 있기 때문이다.
- > 해시 충돌이 없으면 O(1)의 시간으로 탐색 가능

**2. 적은 자원**으로 **많은 양의 데이터**를 효율적으로 관리할 수 있기 때문

- **> 하드디스크나, 클라우드에 존재하는 무한한 데이터들을 유한한 개수의 해시값으로 매핑하면 작은 메모리로도 프로세스 관리가 가능해진다고 한다.**
